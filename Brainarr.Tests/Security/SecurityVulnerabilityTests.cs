using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Xunit;
using FluentAssertions;
using Moq;
using NLog;
using NzbDrone.Common.Http;
using NzbDrone.Core.ImportLists.Brainarr.Services;
using Brainarr.Plugin.Services.Security;

namespace Brainarr.Tests.Security
{
    /// <summary>
    /// Comprehensive security tests for critical vulnerabilities identified in the audit
    /// </summary>
    [Trait("Category", "Security")]
    public class SecurityVulnerabilityTests
    {
        private readonly Mock<IHttpClient> _httpClient;
        private readonly Mock<Logger> _logger;
        
        public SecurityVulnerabilityTests()
        {
            _httpClient = new Mock<IHttpClient>();
            _logger = new Mock<Logger>();
        }
        
        #region JSON Deserialization Attack Tests
        
        [Fact]
        public void SecureJsonSerializer_Should_RejectMaliciousPayloads()
        {
            // Arrange - Various attack payloads
            var attackPayloads = new[]
            {
                "{\"$type\":\"System.Windows.Data.ObjectDataProvider, PresentationFramework\"}",
                "{\"__proto__\":{\"isAdmin\":true}}",
                "{\"constructor\":{\"prototype\":{\"isAdmin\":true}}}",
                "{\"$id\":\"1\",\"$ref\":\"1\"}", // Reference loop
                "{'__defineGetter__':'alert(1)'}",
                "{\"eval\":\"process.exit(1)\"}",
                "{\"Function\":\"return process.mainModule.require('child_process').execSync('calc')\"}",
                "<script>alert('XSS')</script>",
                "{\"javascript:\":\"alert(1)\"}",
                "{\"data:text/html\":\"<script>alert(1)</script>\"}"
            };
            
            // Act & Assert
            foreach (var payload in attackPayloads)
            {
                var exception = Assert.Throws<InvalidOperationException>(() => 
                    SecureJsonSerializer.Deserialize<object>(payload));
                    
                exception.Message.Should().Contain("malicious", "potentially malicious");
            }
        }
        
        [Fact]
        public void SecureJsonSerializer_Should_EnforceMaxDepth()
        {
            // Arrange - Deeply nested JSON (depth > 20)
            var deepJson = "{";
            for (int i = 0; i < 25; i++)
            {
                deepJson += "\"level" + i + "\":{";
            }
            for (int i = 0; i < 25; i++)
            {
                deepJson += "}";
            }
            deepJson += "}";
            
            // Act & Assert
            var exception = Assert.Throws<InvalidOperationException>(() => 
                SecureJsonSerializer.Deserialize<object>(deepJson));
                
            exception.Message.Should().Contain("nesting depth exceeds safe limit");
        }
        
        [Fact]
        public void SecureJsonSerializer_Should_EnforceMaxSize()
        {
            // Arrange - JSON larger than 10MB
            var largeJson = "{\"data\":\"" + new string('A', 11 * 1024 * 1024) + "\"}";
            
            // Act & Assert
            var exception = Assert.Throws<InvalidOperationException>(() => 
                SecureJsonSerializer.Deserialize<object>(largeJson));
                
            exception.Message.Should().Contain("exceeds maximum allowed size");
        }
        
        #endregion
        
        #region API Key Validation Tests
        
        [Theory]
        [InlineData("OpenAI", "sk-test123", "Test or demo API keys are not allowed")]
        [InlineData("OpenAI", "sk-" + "A" * 100, "API key format is invalid")]
        [InlineData("Anthropic", "sk-ant-demo123", "Test or demo API keys are not allowed")]
        [InlineData("Perplexity", "pplx-SELECT * FROM users", "suspicious pattern")]
        [InlineData("OpenRouter", "../../etc/passwd", "suspicious pattern")]
        [InlineData("DeepSeek", "<script>alert(1)</script>", "suspicious pattern")]
        [InlineData("Gemini", "'; DROP TABLE users; --", "suspicious pattern")]
        [InlineData("Groq", "gsk_\0\0\0", "invalid control characters")]
        public void ApiKeyValidator_Should_RejectMaliciousKeys(string provider, string apiKey, string expectedError)
        {
            // Act
            var result = ApiKeyValidator.ValidateApiKey(apiKey, provider);
            
            // Assert
            result.IsValid.Should().BeFalse();
            result.Error.Should().Contain(expectedError);
        }
        
        [Theory]
        [InlineData("OpenAI", "sk-" + "a1B2c3D4e5F6g7H8i9J0k1L2m3N4o5P6q7R8s9T0u1V2w3X4y5Z6")]
        [InlineData("Anthropic", "sk-ant-api03-" + "a1B2c3D4e5F6g7H8i9J0k1L2m3N4o5P6q7R8")]
        [InlineData("Perplexity", "pplx-" + "a1B2c3D4e5F6g7H8i9J0k1L2m3N4o5P6q7R8s9T0")]
        [InlineData("Groq", "gsk_" + "a1B2c3D4e5F6g7H8i9J0k1L2m3N4o5P6q7R8s9T0u1V2w3X4y5Z6")]
        public void ApiKeyValidator_Should_AcceptValidKeys(string provider, string apiKey)
        {
            // Act
            var result = ApiKeyValidator.ValidateApiKey(apiKey, provider);
            
            // Assert
            result.IsValid.Should().BeTrue();
            result.SanitizedKey.Should().Be(apiKey);
        }
        
        [Fact]
        public void ApiKeyValidator_Should_DetectRepeatedCharacters()
        {
            // Arrange
            var testKey = "sk-" + new string('A', 48);
            
            // Act
            var result = ApiKeyValidator.ValidateApiKey(testKey, "OpenAI");
            
            // Assert
            result.IsValid.Should().BeFalse();
            result.IsTestKey.Should().BeTrue();
        }
        
        #endregion
        
        #region Rate Limiting Bounds Tests
        
        [Theory]
        [InlineData(0, 10)] // Invalid requests count
        [InlineData(-1, 10)] // Negative requests
        [InlineData(1001, 1000)] // Exceeds max
        [InlineData(10000, 1000)] // Way over max
        public void RateLimiter_Should_EnforceBounds_OnMaxRequests(int input, int expected)
        {
            // Arrange
            var rateLimiter = new RateLimiter(_logger.Object);
            
            // Act
            rateLimiter.Configure("test", input, TimeSpan.FromMinutes(1));
            
            // Assert
            _logger.Verify(l => l.Warn(It.IsAny<string>()), Times.AtLeastOnce);
        }
        
        [Theory]
        [InlineData(0, 60)] // Invalid period
        [InlineData(-60, 60)] // Negative period
        [InlineData(86401, 86400)] // Over 24 hours
        public void RateLimiter_Should_EnforceBounds_OnPeriod(int inputSeconds, int expectedSeconds)
        {
            // Arrange
            var rateLimiter = new RateLimiter(_logger.Object);
            var inputPeriod = TimeSpan.FromSeconds(inputSeconds);
            
            // Act
            rateLimiter.Configure("test", 10, inputPeriod);
            
            // Assert
            if (inputSeconds <= 0 || inputSeconds > 86400)
            {
                _logger.Verify(l => l.Warn(It.IsAny<string>()), Times.AtLeastOnce);
            }
        }
        
        [Fact]
        public void RateLimiter_Should_PreventExcessiveRatePerSecond()
        {
            // Arrange
            var rateLimiter = new RateLimiter(_logger.Object);
            
            // Act - Try to set 1000 requests per second
            rateLimiter.Configure("test", 1000, TimeSpan.FromSeconds(1));
            
            // Assert
            _logger.Verify(l => l.Warn(It.Is<string>(s => s.Contains("requests/second is excessive"))), Times.Once);
        }
        
        #endregion
        
        #region Async/Deadlock Prevention Tests
        
        [Fact]
        public async Task BrainarrImportList_Should_NotDeadlock_UnderLoad()
        {
            // This test verifies the async fix prevents deadlocks
            // by running multiple concurrent fetch operations
            
            // Arrange
            var tasks = new List<Task>();
            var importList = CreateImportListInstance();
            
            // Act - Run 10 concurrent fetches
            for (int i = 0; i < 10; i++)
            {
                tasks.Add(Task.Run(() =>
                {
                    // This should complete without deadlock
                    var result = importList.Fetch();
                    result.Should().NotBeNull();
                }));
            }
            
            // Assert - All tasks should complete within reasonable time
            var allCompleted = await Task.WhenAll(tasks)
                .ContinueWith(t => t.IsCompletedSuccessfully);
                
            allCompleted.Should().BeTrue("All fetch operations should complete without deadlock");
        }
        
        #endregion
        
        #region Thread Safety Tests
        
        [Fact]
        public async Task ProviderRegistry_Should_BeThreadSafe()
        {
            // Arrange
            var registry = new ProviderRegistry();
            var tasks = new List<Task>();
            var providers = new[] { AIProvider.OpenAI, AIProvider.Anthropic, AIProvider.Gemini };
            
            // Act - Concurrent operations
            for (int i = 0; i < 100; i++)
            {
                var provider = providers[i % providers.Length];
                
                // Mix of operations
                tasks.Add(Task.Run(() =>
                {
                    registry.IsRegistered(provider);
                    registry.GetRegisteredProviders();
                    
                    if (i % 3 == 0)
                    {
                        try
                        {
                            registry.CreateProvider(provider, CreateMockSettings(), 
                                _httpClient.Object, _logger.Object);
                        }
                        catch { /* Expected for some providers */ }
                    }
                }));
            }
            
            await Task.WhenAll(tasks);
            
            // Assert - No exceptions from thread safety issues
            tasks.All(t => t.IsCompletedSuccessfully).Should().BeTrue();
        }
        
        #endregion
        
        #region ReDoS Prevention Tests
        
        [Fact]
        public void InputSanitizer_Should_PreventReDoS()
        {
            // Arrange - Create a string that could cause catastrophic backtracking
            var maliciousInput = "SELECT" + new string('A', 10000) + "FROM";
            
            // Act - This should complete quickly due to truncation
            var startTime = DateTime.UtcNow;
            var result = new InputSanitizer(_logger.Object).SanitizePrompt(maliciousInput);
            var elapsed = DateTime.UtcNow - startTime;
            
            // Assert
            elapsed.Should().BeLessThan(TimeSpan.FromSeconds(1), 
                "Regex should complete quickly due to truncation protection");
            result.Should().NotBeNullOrEmpty();
        }
        
        #endregion
        
        #region Memory Leak Prevention Tests
        
        [Fact]
        public void ConcurrentCache_Should_NotLeakMemory()
        {
            // Arrange
            var cache = new ConcurrentCache<string, object>(
                maxSize: 100,
                cleanupInterval: TimeSpan.FromMilliseconds(100),
                _logger.Object);
            
            // Act - Add more items than max size
            for (int i = 0; i < 1000; i++)
            {
                cache.Set($"key{i}", new byte[1024], TimeSpan.FromMinutes(5));
            }
            
            // Wait for cleanup
            System.Threading.Thread.Sleep(200);
            
            // Assert - Cache should not exceed max size
            var stats = cache.GetStatistics();
            stats.CurrentSize.Should().BeLessOrEqualTo(100);
        }
        
        #endregion
        
        #region Null Reference Prevention Tests
        
        [Fact]
        public void Services_Should_HandleNullInputsGracefully()
        {
            // Test various services with null inputs
            
            // API Key Validator
            var keyResult = ApiKeyValidator.ValidateApiKey(null, "OpenAI");
            keyResult.IsValid.Should().BeFalse();
            keyResult.Error.Should().Contain("cannot be empty");
            
            // Secure JSON Serializer
            Assert.Throws<ArgumentNullException>(() => 
                SecureJsonSerializer.Deserialize<object>(null));
            
            // Rate Limiter
            var limiter = new RateLimiter(_logger.Object);
            limiter.Configure(null, 10, TimeSpan.FromMinutes(1));
            _logger.Verify(l => l.Warn(It.IsAny<string>()), Times.Once);
        }
        
        #endregion
        
        // Helper methods
        
        private BrainarrImportList CreateImportListInstance()
        {
            // Create a mock instance for testing
            var mockStatusService = new Mock<IImportListStatusService>();
            var mockConfigService = new Mock<IConfigService>();
            var mockParsingService = new Mock<IParsingService>();
            var mockArtistService = new Mock<IArtistService>();
            var mockAlbumService = new Mock<IAlbumService>();
            
            return new BrainarrImportList(
                mockStatusService.Object,
                mockConfigService.Object,
                mockParsingService.Object,
                _httpClient.Object,
                mockArtistService.Object,
                mockAlbumService.Object,
                _logger.Object);
        }
        
        private BrainarrSettings CreateMockSettings()
        {
            return new BrainarrSettings
            {
                Provider = AIProvider.OpenAI,
                OpenAIApiKey = "sk-test123456789012345678901234567890123456789012",
                MaxRecommendations = 10
            };
        }
    }
}