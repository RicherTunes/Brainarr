#!/usr/bin/env bash\nset -euo pipefail\n\nRED='\033[0;31m'\nGRN='\033[0;32m'\nNC='\033[0m'\n\nfail() { echo -e "${RED}✖ $*${NC}"; exit 1; }\nok() { echo -e "${GRN}✔ $*${NC}"; }\n\nroot_dir="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")"/.. && pwd)"\ncd "$root_dir"\n\n# Extract versions\nplugin_version=$(grep -Po '"version":\s*"\K[^\"]+' plugin.json | head -n1 || true)\nmin_version=$(grep -Po '"minimumVersion":\s*"\K[^\"]+' plugin.json | head -n1 || true)\nmanifest_version=$(grep -Po '"version":\s*"\K[^\"]+' manifest.json | head -n1 || true)\nmanifest_min_version=$(grep -Po '"minimumVersion":\s*"\K[^\"]+' manifest.json | head -n1 || true)\n\n# Normalize potential CR from Windows line endings\nplugin_version=${plugin_version%$'\r'}\nmin_version=${min_version%$'\r'}\nmanifest_version=${manifest_version%$'\r'}\nmanifest_min_version=${manifest_min_version%$'\r'}\n\n[[ -n "$plugin_version" ]] || fail "Could not read plugin version from plugin.json"\n[[ -n "$min_version" ]] || fail "Could not read minimumVersion from plugin.json"\n[[ -n "$manifest_version" ]] || fail "Could not read version from manifest.json"\n[[ -n "$manifest_min_version" ]] || fail "Could not read minimumVersion from manifest.json"\n\n[[ "$manifest_version" == "$plugin_version" ]] || fail "manifest.json version ($manifest_version) != plugin.json version ($plugin_version)"\n[[ "$manifest_min_version" == "$min_version" ]] || fail "manifest.json minimumVersion ($manifest_min_version) != plugin.json minimumVersion ($min_version)"\n\n# README badge version\nreadme_version=$(grep -Po 'version-\K[0-9]+\.[0-9]+\.[0-9]+' README.md | head -n1 || true)\n[[ -n "$readme_version" ]] || fail "Could not find version badge in README.md"\n[[ "$readme_version" == "$plugin_version" ]] || fail "README badge version ($readme_version) != plugin.json version ($plugin_version)"\n\n# docs/PLUGIN_MANIFEST.md example versions must match\nmapfile -t doc_versions < <(grep -Po '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' docs/PLUGIN_MANIFEST.md | tr -d '\r' | sort -u)\nfor v in "${doc_versions[@]}"; do\n  v=${v%$'\r'}\n  [[ "$v" == "$plugin_version" ]] || fail "docs/PLUGIN_MANIFEST.md version example ($v) does not match plugin.json ($plugin_version)"\ndone\n\n# minimumVersion mentions must match, exclude archive\nmapfile -t min_mentions < <(grep -hRPo --exclude-dir=archive '"minimumVersion":\s*"\K[^\"]+' docs | tr -d '\r' | sort -u)\nfor mv in "${min_mentions[@]}"; do\n  mv=${mv%$'\r'}\n  [[ "$mv" == "$min_version" ]] || fail "docs minimumVersion mention ($mv) != plugin.json minimumVersion ($min_version)"\ndone\n\n# No old minimum version leftovers (like 4.0.0.0) outside archive\nif grep -R "4\.0\.0\.0" docs wiki-content | grep -v /archive/ >/dev/null 2>&1; then\n  fail "Found legacy minimum version 4.0.0.0 in docs/wiki"\nfi\n\n# Path layout: no ownerless plugin paths\nbad_paths=(\n  "/plugins/Brainarr"\n  "C:\\ProgramData\\Lidarr\\plugins\\Brainarr"\n  "/config/plugins/Brainarr"\n)\nfor pat in "${bad_paths[@]}"; do\n  if grep -R --binary-files=without-match -F "$pat" README.md docs wiki-content >/dev/null 2>&1; then\n    fail "Found deprecated path pattern: $pat"\n  fi\ndone\n\n# Compatibility block present in key pages\ncomp_text="Requires Lidarr $min_version+ on the plugins/nightly branch"\nmust_have=(\n  "README.md"\n  "docs/PROVIDER_GUIDE.md"\n  "docs/DEPLOYMENT.md"\n  "docs/USER_SETUP_GUIDE.md"\n  "wiki-content/Installation.md"\n  "wiki-content/Home.md"\n)\nfor f in "${must_have[@]}"; do\n  if ! grep -Eq "Requires Lidarr \\*{0,2}${min_version}\\+\\*{0,2} on the \\*{0,2}plugins/nightly\\*{0,2} branch" "$f"; then\n    fail "Missing compatibility notice in $f"\n  fi\ndone\n\n# Provider matrix alignment between README, wiki, and docs\nextract_matrix() {\n  local file="$1"\n  awk '\n    /<!-- PROVIDER_MATRIX_START -->/ { in_block=1; next }\n    /<!-- PROVIDER_MATRIX_END -->/ { in_block=0; exit }\n    { if (in_block) print }\n  ' "$file" | tr -d '\r' | sed 's/[[:space:]]\+$//'\n}\n\nmatrix_docs=$(extract_matrix "docs/PROVIDER_MATRIX.md")\n[[ -n "$matrix_docs" ]] || fail "Missing provider matrix block in docs/PROVIDER_MATRIX.md"\n\nmatrix_readme=$(extract_matrix "README.md")\n[[ -n "$matrix_readme" ]] || fail "Missing provider matrix block in README.md"\n\nmatrix_wiki=$(extract_matrix "wiki-content/Home.md")\n[[ -n "$matrix_wiki" ]] || fail "Missing provider matrix block in wiki-content/Home.md"\n\nif ! diff -u --label docs/PROVIDER_MATRIX.md --label README.md \\n       <(printf '%s\n' "$matrix_docs") <(printf '%s\n' "$matrix_readme"); then\n  fail "Provider matrix mismatch between docs/PROVIDER_MATRIX.md and README.md"\nfi\n\nif ! diff -u --label docs/PROVIDER_MATRIX.md --label wiki-content/Home.md \\n       <(printf '%s\n' "$matrix_docs") <(printf '%s\n' "$matrix_wiki"); then\n  fail "Provider matrix mismatch between docs/PROVIDER_MATRIX.md and wiki-content/Home.md"\nfi\n\nexpected_release="Latest release: **v${plugin_version}**"\ngrep -F "$expected_release" README.md >/dev/null 2>&1 || fail "README missing latest release line ($expected_release)"\ngrep -F "$expected_release" wiki-content/Home.md >/dev/null 2>&1 || fail "Wiki Home missing latest release line ($expected_release)"\n\nif ! grep -F "Brainarr Provider Matrix (v${plugin_version})" docs/PROVIDER_MATRIX.md >/dev/null 2>&1; then\n  fail "docs/PROVIDER_MATRIX.md header not updated for v${plugin_version}"\nfi\n\nok "Docs consistency checks passed (version=$plugin_version, minimumVersion=$min_version)"\n
