name: CI

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'wiki-content/**'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'wiki-content/**'
  release:
    types: [ published ]

env:
  DOTNET_VERSION: 8.0.404
  PLUGIN_VERSION: 1.0.${{ github.run_number }}
  LIDARR_DOCKER_VERSION: pr-plugins-2.14.2.4786
  CI: true

defaults:
  run:
    shell: bash

jobs:
  test:
    name: Test & Build
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.os }}-${{ matrix.dotnet-version }}
      cancel-in-progress: true
    # Only gate on ubuntu-latest builds; others are advisory
    continue-on-error: ${{ matrix.os != 'ubuntu-latest' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['8.0.x']

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: recursive
        token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

    - name: Force PAT for submodules
      shell: bash
      env:
        SUBMODULES_TOKEN: ${{ secrets.SUBMODULES_TOKEN }}
      run: |
        if [ -n "${SUBMODULES_TOKEN}" ]; then
          git config --global url."https://x-access-token:${SUBMODULES_TOKEN}@github.com/".insteadOf "https://github.com/"
        fi

    - name: Patch submodule NuGet mapping (TagLibSharp-Lidarr)
      uses: ./.github/actions/patch-taglib-mapping

    - name: Extract Lidarr assemblies from Docker
      shell: bash
      run: |
        set -euo pipefail
        echo "Extracting Lidarr assemblies including Equ.dll and dependencies..."
        bash scripts/extract-lidarr-assemblies.sh --mode minimal --output-dir ext/Lidarr/_output/net8.0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Ensure ripgrep is installed
      if: matrix.os == 'ubuntu-latest'
      run: |
        if ! command -v rg >/dev/null 2>&1; then
          sudo apt-get update
          sudo apt-get install -y ripgrep
        else
          echo "ripgrep already installed"
        fi
      shell: bash

    - name: Restore (for formatting)
      if: matrix.os == 'ubuntu-latest'
      run: dotnet restore Brainarr.sln

    - name: Ensure dotnet-format is available
      if: matrix.os == 'ubuntu-latest'
      run: |
        set -e
        if ! dotnet format --version >/dev/null 2>&1; then
          echo "dotnet-format not found; installing as global tool..."
          dotnet tool update -g dotnet-format
          echo "$HOME/.dotnet/tools" >> $GITHUB_PATH
        fi
      shell: bash

    - name: Check formatting
      if: matrix.os == 'ubuntu-latest'
      run: |
        # Exclude submodules and external code from formatting gate
        dotnet format --verify-no-changes --exclude "ext/lidarr.plugin.common/**" --exclude "ext/Lidarr/**" || (
          echo "Formatting issues detected. Run 'dotnet format' locally." && exit 1
        )
      shell: bash

    - name: Static Guards
      if: matrix.os == 'ubuntu-latest'
      run: |
        echo "Checking for CancellationToken.None in product code..."
        set -e
        MATCHES=$(rg -n "CancellationToken\.None" Brainarr.Plugin -S || true)
        if [ -n "$MATCHES" ]; then
          echo "Found forbidden CancellationToken.None usages:"; echo "$MATCHES"; exit 1;
        fi
        echo "Checking for DateTime.Now in product code..."
        MATCHES=$(rg -n "DateTime\.Now" Brainarr.Plugin -S || true)
        if [ -n "$MATCHES" ]; then
          echo "Found DateTime.Now usages (use UtcNow):"; echo "$MATCHES"; exit 1;
        fi
        echo "Checking for Thread.Sleep in product code..."
        MATCHES=$(rg -n "Thread\.Sleep\(" Brainarr.Plugin -S || true)
        if [ -n "$MATCHES" ]; then
          echo "Found Thread.Sleep usages (use Task.Delay + CancellationToken):"; echo "$MATCHES"; exit 1;
        fi
        echo "Checking for sync-over-async (.GetAwaiter().GetResult()) in product code..."
        MATCHES=$(rg -n "\.GetAwaiter\(\)\.GetResult\(\)" Brainarr.Plugin -S | rg -v "SafeAsyncHelper\.cs|\.md:" || true)
        if [ -n "$MATCHES" ]; then
          echo "Found sync-over-async usages:"; echo "$MATCHES"; exit 1;
        fi
        echo "Checking for Task.Result in product code..."
        # Only flag actual property access on a Task instance (e.g., foo.Result), not type names or comments
        MATCHES=$(rg -n "\.Result\b" Brainarr.Plugin -S | rg -v "SafeAsyncHelper|RunSync|RunSafeSync|\\.Tests|^\s*//|^\s*///|^\s*/\*|^\s*\*" || true)
        if [ -n "$MATCHES" ]; then
          echo "Found Task.Result usages (forbidden in product code):"; echo "$MATCHES"; exit 1;
        fi
      shell: bash

    - name: Layering Guards
      if: matrix.os == 'ubuntu-latest'
      run: |
        set -e
        echo "Enforcing layering: Providers must not depend on Services.Core"
        BAD1=$(rg -n "using\s+NzbDrone\.Core\.ImportLists\.Brainarr\.Services\.Core" Brainarr.Plugin/Services/Providers -S || true)
        if [ -n "$BAD1" ]; then
          echo "Providers referencing Services.Core:"; echo "$BAD1"; exit 1;
        fi
        echo "Enforcing layering: Core must not reference concrete provider implementations"
        BAD2=$(rg -n "NzbDrone\.Core\.ImportLists\.Brainarr\.Services\.Providers\." Brainarr.Plugin/Services/Core -S || true)
        if [ -n "$BAD2" ]; then
          echo "Core referencing Services.Providers concrete types:"; echo "$BAD2"; exit 1;
        fi
      shell: bash

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore Brainarr.sln

    - name: Build
      run: dotnet build Brainarr.sln --no-restore --configuration Release -m:1
      shell: bash

    - name: Test (Unit-only PR gate)
      continue-on-error: true
      timeout-minutes: 10
      shell: bash
      run: |
        echo "Running unit-only gate with timeout protection..."
        mkdir -p TestResults
        dotnet test Brainarr.sln --no-build --configuration Release \
          --verbosity normal \
          --settings Brainarr.Tests/test.fast.runsettings \
          --filter "(Category=Unit|TestCategory=Unit)" \
          --logger "trx;LogFileName=test-results.trx" \
          --collect "XPlat Code Coverage" \
          --results-directory TestResults/

    - name: Provider-Contract (OpenAI)
      if: matrix.os == 'ubuntu-latest'
      timeout-minutes: 10
      shell: bash
      run: |
        echo "Running provider-contract tests (OpenAI) with timeout protection..."
        mkdir -p TestResults/ProviderContract
        timeout 12m dotnet test tests/Brainarr.Providers.OpenAI.Tests/Brainarr.Providers.OpenAI.Tests.csproj --no-build --configuration Release \
          --verbosity normal \
          --filter "scope=provider-contract" \
          --logger "trx;LogFileName=provider-contract.trx" \
          --results-directory TestResults/ProviderContract/

    - name: List TestResults before upload
      if: ${{ always() }}
      shell: bash
      run: |
        echo "PWD=$(pwd)"
        echo "Listing TestResults contents (up to depth 3)"
        find TestResults -maxdepth 3 -type f -print || true
        mkdir -p TestResults
        touch TestResults/.keep

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.os }}-${{ matrix.dotnet-version }}
        path: |
          TestResults/
          TestResults/ProviderContract/**
        if-no-files-found: warn

    - name: Package Plugin (Ubuntu only)
      if: matrix.os == 'ubuntu-latest'
      run: |
        echo "Packaging plugin build artifacts..."
        mkdir -p artifacts

        # Copy built plugin files
        cp -r Brainarr.Plugin/bin/Release/net8.0/* artifacts/ 2>/dev/null || true

        # Copy plugin manifest
        cp plugin.json artifacts/

        # Create version info
        echo "Build Date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" > artifacts/BUILD_INFO.txt
        echo "Git Commit: ${{ github.sha }}" >> artifacts/BUILD_INFO.txt
        echo "Git Branch: ${{ github.ref_name }}" >> artifacts/BUILD_INFO.txt
        echo "Runner OS: ${{ matrix.os }}" >> artifacts/BUILD_INFO.txt
        echo ".NET Version: ${{ matrix.dotnet-version }}" >> artifacts/BUILD_INFO.txt

        # Create artifact zip
        cd artifacts
        zip -r ../brainarr-ci-build-${{ github.run_number }}.zip .
        cd ..

    - name: Upload Build Artifacts
      if: matrix.os == 'ubuntu-latest'
      uses: actions/upload-artifact@v4
      with:
        name: brainarr-build-${{ github.run_number }}
        path: |
          artifacts/
          brainarr-ci-build-${{ github.run_number }}.zip
        retention-days: 30

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      if: matrix.os == 'ubuntu-latest' && env.CODECOV_TOKEN != ''
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      with:
        file: TestResults/*/coverage.cobertura.xml
        flags: unittests
        name: codecov-umbrella
        token: ${{ env.CODECOV_TOKEN }}
        fail_ci_if_error: false

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      actions: read
      contents: read
      security-events: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0
        token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

    - name: Force PAT for submodules (security scan)
      shell: bash
      env:
        SUBMODULES_TOKEN: ${{ secrets.SUBMODULES_TOKEN }}
      run: |
        if [ -n "${SUBMODULES_TOKEN}" ]; then
          git config --global url."https://x-access-token:${SUBMODULES_TOKEN}@github.com/".insteadOf "https://github.com/"
        fi

    - name: Patch submodule NuGet mapping (TagLibSharp-Lidarr) [security scan]
      uses: ./.github/actions/patch-taglib-mapping

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v3
      with:
        languages: csharp

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Patch submodule NuGet mapping (TagLibSharp-Lidarr)
      shell: bash
      run: |
        set -euo pipefail
        CFG="ext/lidarr.plugin.common/NuGet.config"
        if [ -f "$CFG" ]; then
          if ! rg -n "TagLibSharp-Lidarr\*" "$CFG" -S >/dev/null 2>&1; then
            echo "Patching $CFG to map TagLibSharp-Lidarr* to lidarr-taglib source"
            awk '
              /<packageSource key=\"lidarr-taglib\">/ { print; print "      <package pattern=\"TagLibSharp-Lidarr*\" />"; next }1
            ' "$CFG" > "$CFG.tmp" && mv "$CFG.tmp" "$CFG"
          fi
        fi

    - name: Build for Analysis
      shell: bash
      run: |
        dotnet restore Brainarr.sln
        dotnet build Brainarr.sln --configuration Release -p:TreatWarningsAsErrors=false -m:1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3

  update-wiki:
    name: ðŸ“š Update Wiki Documentation
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    continue-on-error: true
    permissions:
      contents: write  # Required to push to wiki repository
      actions: read
      pages: write     # Required for wiki operations

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Update Wiki with Latest Changes
      run: |
        echo "ðŸ“š Updating wiki documentation for latest changes..."

        # Clone wiki repository with authentication
        git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo || {
          echo "âš ï¸ Wiki repository doesn't exist yet - skipping wiki update"
          echo "ðŸ’¡ Create first wiki page manually to enable auto-updates"
          exit 0
        }

        cd wiki-repo

        # Update wiki content from source
        echo "ðŸ”„ Syncing wiki content with latest codebase..."

        # Copy any updated wiki content files
        if [ -d "../wiki-content" ]; then
          cp ../wiki-content/*.md . 2>/dev/null || echo "No wiki content files found"

          # Remove file extensions for wiki page names
          for file in *.md; do
            if [[ "$file" != *.md ]]; then continue; fi
            base=$(basename "$file" .md)
            if [[ "$base" == *"-"* ]]; then
              new_name=$(echo "$base" | sed 's/-/ /g').md
              if [[ "$file" != "$new_name" ]]; then
                mv "$file" "$new_name"
                echo "ðŸ“„ Renamed: $file â†’ $new_name"
              fi
            fi
          done
        fi

        # Check for changes
        if git diff --quiet && git diff --cached --quiet; then
          echo "â„¹ï¸ No wiki updates needed"
        else
          echo "ðŸ“ Committing wiki updates..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .
          git commit -m "docs: sync wiki with latest codebase changes

          Automated wiki update from commit ${{ github.sha }}

          â€¢ Synchronized documentation with code changes
          â€¢ Updated based on latest implementation details
          â€¢ Maintained accuracy with source of truth (codebase)

          Auto-updated by CI pipeline."

          git push origin master || git push origin main
          echo "âœ… Wiki synchronized successfully"
          echo "ðŸ”— View updated wiki: https://github.com/${{ github.repository }}/wiki"
        fi

        cd ..
        rm -rf wiki-repo

  build-plugin:
    name: Build Plugin Release
    runs-on: ubuntu-latest
    needs: test
    if: false  # Disabled - releases handled by release.yml workflow

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Build Plugin
      shell: bash
      run: |
        dotnet restore Brainarr.sln
        dotnet build Brainarr.sln --configuration Release -m:1

        # Verify build output
        echo "=== Build Output Verification ==="
        find . -name "Lidarr.Plugin.Brainarr.dll" -type f
        find . -name "*.dll" -path "*/bin/*" | head -10

    - name: Create Release Package
      shell: bash
      run: |
        mkdir -p release

        # Find and copy the built DLL with better error handling
        if [ -f "Brainarr.Plugin/bin/Lidarr.Plugin.Brainarr.dll" ]; then
          cp "Brainarr.Plugin/bin/Lidarr.Plugin.Brainarr.dll" release/
          echo "âœ… Found DLL at Brainarr.Plugin/bin/"
        elif [ -f "Brainarr.Plugin/bin/Release/net8.0/Lidarr.Plugin.Brainarr.dll" ]; then
          cp "Brainarr.Plugin/bin/Release/net8.0/Lidarr.Plugin.Brainarr.dll" release/
          echo "âœ… Found DLL at Brainarr.Plugin/bin/Release/net8.0/"
        else
          echo "âŒ Could not find Lidarr.Plugin.Brainarr.dll"
          echo "Available files in Brainarr.Plugin/bin/:"
          find Brainarr.Plugin/bin/ -name "*.dll" 2>/dev/null || echo "No DLLs found"
          exit 1
        fi

        # Copy additional files
        cp plugin.json release/
        cp README.md release/
        cp LICENSE release/

        # Create the release package
        cd release
        zip -r ../Brainarr-${{ github.event.release.tag_name }}.zip .
        cd ..

        echo "=== Release Package Contents ==="
        unzip -l "Brainarr-${{ github.event.release.tag_name }}.zip"

    - name: Upload Release Assets
      run: |
        # Upload main plugin package
        gh release upload ${{ github.event.release.tag_name }} \
          "Brainarr-${{ github.event.release.tag_name }}.zip" \
          --clobber

        # Upload .NET 8.0 specific package for compatibility
        cp "Brainarr-${{ github.event.release.tag_name }}.zip" "Brainarr-${{ github.event.release.tag_name }}.net8.0.zip"
        gh release upload ${{ github.event.release.tag_name }} \
          "Brainarr-${{ github.event.release.tag_name }}.net8.0.zip" \
          --clobber

        # Create and upload SHA256 checksums for verification
        sha256sum "Brainarr-${{ github.event.release.tag_name }}.zip" > "Brainarr-${{ github.event.release.tag_name }}.zip.sha256"
        sha256sum "Brainarr-${{ github.event.release.tag_name }}.net8.0.zip" > "Brainarr-${{ github.event.release.tag_name }}.net8.0.zip.sha256"

        gh release upload ${{ github.event.release.tag_name }} \
          "Brainarr-${{ github.event.release.tag_name }}.zip.sha256" \
          "Brainarr-${{ github.event.release.tag_name }}.net8.0.zip.sha256" \
          --clobber
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
