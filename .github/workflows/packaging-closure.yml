name: Packaging Closure

on:
  push:
    branches: [main]
    paths:
      - 'Brainarr.Plugin/**'
      - 'plugin.json'
      - 'manifest.json'
  pull_request:
    branches: [main]
    paths:
      - 'Brainarr.Plugin/**'
      - 'plugin.json'
      - 'manifest.json'

permissions:
  contents: read

jobs:
  verify-package-closure:
    name: Verify Package Closure
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: false
        token: ${{ github.token }}

    - name: Init Common submodule
      uses: ./.github/actions/init-common-submodule
      with:
        token: ${{ secrets.SUBMODULES_TOKEN }}

    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '6.0.x'

    - name: Extract Lidarr Assemblies
      shell: bash
      run: |
        timeout 15m bash scripts/extract-lidarr-assemblies.sh --mode full --no-tar-fallback --output-dir ext/Lidarr-docker/_output/net8.0
        echo "Extracted assemblies (sample):"
        ls -1 ext/Lidarr-docker/_output/net8.0 2>/dev/null | head -20 || true

    - name: Build Plugin
      shell: bash
      run: |
        dotnet restore Brainarr.Plugin/Brainarr.Plugin.csproj
        dotnet build Brainarr.Plugin/Brainarr.Plugin.csproj \
          --configuration Release \
          --no-restore \
          -p:LidarrPath="${{ github.workspace }}/ext/Lidarr-docker/_output/net8.0" \
          -m:1

    - name: Create Plugin Package (with Canonical Abstractions + Entrypoint Validation)
      shell: pwsh
      run: |
        # Use unified PluginPack tooling (same as build.ps1 -Package)
        $modulePath = 'ext/lidarr.plugin.common/tools/PluginPack.psm1'
        if (-not (Test-Path $modulePath)) {
            Write-Error "PluginPack.psm1 not found at $modulePath"
            exit 1
        }
        Import-Module $modulePath -Force

        # Canonical Abstractions injection + entrypoint validation
        $packagePath = New-PluginPackage `
            -Csproj 'Brainarr.Plugin/Brainarr.Plugin.csproj' `
            -Manifest 'plugin.json' `
            -Framework 'net8.0' `
            -Configuration 'Release' `
            -RequireCanonicalAbstractions `
            -ResolveEntryPoints

        Write-Host "Package created: $packagePath"

        # Rename for artifact upload
        Copy-Item $packagePath 'Brainarr-closure-test.zip'

    - name: Verify Dependency Closure
      shell: bash
      run: |
        set -euo pipefail

        zipfile="Brainarr-closure-test.zip"

        echo "=== Verifying package closure ==="

        # List all DLLs in the package
        dlls=$(unzip -l "$zipfile" | grep '\.dll$' | awk '{print $4}' | xargs -I {} basename {})
        echo "DLLs in package: $dlls"

        # Allowed Lidarr.* assemblies (plugin-specific)
        allowed="Lidarr.Plugin.Brainarr.dll Lidarr.Plugin.Common.dll Lidarr.Plugin.Abstractions.dll"

        # Check for disallowed host assemblies
        disallowed=""
        for dll in $dlls; do
          if echo "$dll" | grep -qE '^Lidarr\.' && ! echo "$allowed" | grep -qw "$dll"; then
            disallowed="$disallowed $dll"
          fi
          # Also check for NzbDrone assemblies
          if echo "$dll" | grep -qE '^NzbDrone\.'; then
            disallowed="$disallowed $dll"
          fi
        done

        if [ -n "$disallowed" ]; then
          echo "ERROR: Disallowed host assemblies found:$disallowed" >&2
          echo "" >&2
          echo "These assemblies should be provided by the Lidarr runtime, not bundled with the plugin." >&2
          exit 1
        fi

        echo "Dependency closure OK - Canonical Abstractions injected, entrypoints validated"

    - name: Upload Package Artifact
      uses: actions/upload-artifact@v4
      with:
        name: brainarr-closure-test
        path: Brainarr-closure-test.zip
        retention-days: 3
