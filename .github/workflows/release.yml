name: ğŸš€ Automated Release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-alpha.*'
      - 'v*.*.*-beta.*'
      - 'v*.*.*-rc.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.0 or v1.2.0-beta.1)'
        required: true
        type: string
      draft:
        description: 'Create as draft release'
        required: false
        type: boolean
        default: false
  workflow_call:
    inputs:
      version:
        required: true
        type: string
      draft:
        required: false
        type: boolean

env:
  DOTNET_VERSION: '6.0.x'
  # Align with CI default (see AGENTS.md CI Essentials)
  LIDARR_DOCKER_VERSION: 'pr-plugins-2.14.2.4786'

permissions:
  contents: write  # Required for creating releases

jobs:
  create-release:
    name: ğŸ Create Release
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: recursive
        token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '6.0.x'

    - name: Patch submodule NuGet mapping (TagLibSharp-Lidarr)
      shell: bash
      env:
        INPUT_VERSION: ${{ inputs.version }}
        DISPATCH_VERSION: ${{ github.event.inputs.version }}
      run: |
        set -euo pipefail
        CFG="ext/lidarr.plugin.common/NuGet.config"
        if [ -f "$CFG" ]; then
          echo "Patching $CFG to include TagLibSharp-Lidarr mapping..."
          grep -q 'TagLibSharp-Lidarr' "$CFG" || \
            sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' "$CFG"
          echo "Done."
        else
          echo "No submodule NuGet.config found at $CFG"
        fi

    - name: Read pinned plugins digest (if available)
      id: digest
      shell: bash
      run: |
        if [ -f .github/lidarr_digest.txt ]; then
          DIG=$(cat .github/lidarr_digest.txt | tr -d '\n')
          if [[ "$DIG" == sha256:* ]]; then
            echo "LIDARR_DOCKER_DIGEST=$DIG" >> "$GITHUB_ENV"
            echo "Using pinned digest: $DIG"
          fi
        fi

    - name: Extract Lidarr assemblies (plugins Docker)
      shell: bash
      run: |
        set -euo pipefail
        bash scripts/extract-lidarr-assemblies.sh --mode minimal --output-dir ext/Lidarr-docker/_output/net6.0

    - name: Verify assemblies and export LIDARR_PATH (allow tarball)
      shell: bash
      run: |
        set -euo pipefail
        bash scripts/ci/check-assemblies.sh ext/Lidarr-docker/_output/net6.0
        echo "LIDARR_PATH=${{ github.workspace }}/ext/Lidarr-docker/_output/net6.0" >> $GITHUB_ENV

    - name: ğŸ·ï¸ Determine Version & Metadata
      id: version
      shell: bash
      env:
        INPUT_VERSION: ${{ inputs.version }}
        DISPATCH_VERSION: ${{ github.event.inputs.version }}
      run: |
        if [ -n "$DISPATCH_VERSION" ]; then
          VERSION="$DISPATCH_VERSION"
        elif [ -n "$INPUT_VERSION" ]; then
          VERSION="$INPUT_VERSION"
        else
          VERSION="${GITHUB_REF#refs/tags/}"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT

        # Extract semantic version parts
        VERSION_NUM="${VERSION#v}"
        echo "version_num=$VERSION_NUM" >> $GITHUB_OUTPUT

        # Determine if prerelease
        if [[ "$VERSION" =~ -alpha|-beta|-rc ]]; then
          echo "prerelease=true" >> $GITHUB_OUTPUT
          echo "ğŸ§ª Detected prerelease version: $VERSION"
        else
          echo "prerelease=false" >> $GITHUB_OUTPUT
          echo "ğŸ‰ Detected stable release version: $VERSION"
        fi

        # Find previous tag for changelog generation
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
        echo "ğŸ“‹ Previous version: $PREVIOUS_TAG"

    - name: Check if Release exists
      id: check_release
      shell: bash
      run: |
        set -euo pipefail
        TAG="${{ steps.version.outputs.version }}"
        CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG")
        if [ "$CODE" = "200" ]; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release $TAG already exists; downstream steps will be skipped."
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi


    - name: ğŸ”„ Update Version in Project Files
      if: steps.check_release.outputs.exists == 'false'
      shell: bash
      run: |
        VERSION_NUM="${{ steps.version.outputs.version_num }}"
        echo "ğŸ“ Updating version to $VERSION_NUM in project files..."

        # Update plugin.json
        sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION_NUM\"/" plugin.json
        echo "âœ… Updated plugin.json"

        # Update .csproj files if they exist with version properties
        find . -name "*.csproj" -exec grep -l "AssemblyVersion\|FileVersion\|AssemblyInformationalVersion" {} \; | while read file; do
          sed -i "s/<AssemblyVersion>.*<\/AssemblyVersion>/<AssemblyVersion>$VERSION_NUM.0<\/AssemblyVersion>/" "$file"
          sed -i "s/<FileVersion>.*<\/FileVersion>/<FileVersion>$VERSION_NUM.0<\/FileVersion>/" "$file"
          sed -i "s/<AssemblyInformationalVersion>.*<\/AssemblyInformationalVersion>/<AssemblyInformationalVersion>$VERSION_NUM<\/AssemblyInformationalVersion>/" "$file"
          echo "âœ… Updated $file"
        done

        echo "ğŸ¯ Version update completed"

    - name: ğŸ”¨ Build Plugin
      if: steps.check_release.outputs.exists == 'false'
      shell: bash
      run: |
        echo "ğŸ”§ Building Brainarr plugin..."

        # Check what assemblies we actually extracted
        echo "ğŸ“‹ Available Lidarr assemblies:"
        ls -la ext/Lidarr-docker/_output/net6.0/

        # Restore packages first
        dotnet restore Brainarr.sln

        # Build with Docker assemblies + NuGet packages (Microsoft.Extensions now via Central Package Management)
        echo "ğŸ¯ Building with Docker assemblies + NuGet packages..."
        dotnet build Brainarr.sln --configuration Release --no-restore -p:LidarrPath="${{ github.workspace }}/ext/Lidarr-docker/_output/net6.0"

        echo "âœ… Plugin build completed"

    - name: ğŸ§ª Run Tests
      if: steps.check_release.outputs.exists == 'false'
      continue-on-error: true
      timeout-minutes: 10
      shell: bash
      run: |
        echo "ğŸ§ª Running test suite with timeout protection..."
        dotnet test Brainarr.sln --configuration Release --no-build \
          --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --logger trx \
          --results-directory TestResults/ \
          --blame-hang-timeout 5m \
          --blame-hang-dump-type mini
        echo "âœ… Tests completed"

    - name: Package Plugin
      if: steps.check_release.outputs.exists == 'false'
      shell: bash
      run: |
        mkdir -p release

        # Find and copy the main plugin DLL with proper error handling
        if [ -f "Brainarr.Plugin/bin/Lidarr.Plugin.Brainarr.dll" ]; then
          cp Brainarr.Plugin/bin/Lidarr.Plugin.Brainarr.dll release/
          BUILD_PATH="Brainarr.Plugin/bin/"
          echo "âœ… Found plugin DLL at $BUILD_PATH"
        elif [ -f "Brainarr.Plugin/bin/Release/net6.0/Lidarr.Plugin.Brainarr.dll" ]; then
          cp Brainarr.Plugin/bin/Release/net6.0/Lidarr.Plugin.Brainarr.dll release/
          BUILD_PATH="Brainarr.Plugin/bin/Release/net6.0/"
          echo "âœ… Found plugin DLL at $BUILD_PATH"
        else
          echo "âŒ Could not find Lidarr.Plugin.Brainarr.dll"
          echo "Available files:"
          find . -name "*.dll" -path "*/bin/*" | head -10
          exit 1
        fi

        cp plugin.json release/

        # Copy dependencies (NuGet packages) from detected build path
        echo "ğŸ“¦ Copying dependencies from $BUILD_PATH..."
        cp "${BUILD_PATH}Newtonsoft.Json.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}NLog.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}FluentValidation.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.Caching.Memory.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.Caching.Abstractions.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.DependencyInjection.Abstractions.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.Logging.Abstractions.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.Options.dll" release/ 2>/dev/null || true
        cp "${BUILD_PATH}Microsoft.Extensions.Primitives.dll" release/ 2>/dev/null || true

        echo "âœ… Plugin packaging completed"
        echo "ğŸ“¦ Release package contents:"
        ls -la release/

        # Copy documentation
        cp README.md release/
        cp LICENSE release/
        cp CHANGELOG.md release/

        # Create installation guide
        cat > release/INSTALL.txt << 'EOF'
        # Brainarr Plugin Installation

        1. Stop Lidarr
        2. Copy all files to your Lidarr plugins directory:
           - Windows: %ProgramData%\Lidarr\plugins\
           - Linux: /var/lib/lidarr/plugins/
           - Docker: /config/plugins/
        3. Restart Lidarr
        4. Go to Settings > Import Lists > Add Brainarr
        5. Configure your preferred AI provider

        For detailed setup instructions, see README.md
        EOF

        # Create ZIP package
        cd release
        zip -r ../Brainarr-${{ steps.version.outputs.version }}.zip .
        cd ..

        # Create checksums
        sha256sum Brainarr-${{ steps.version.outputs.version }}.zip > Brainarr-${{ steps.version.outputs.version }}.zip.sha256

    - name: Generate SBOM (SPDX JSON)
      if: steps.check_release.outputs.exists == 'false'
      uses: anchore/sbom-action@v0
      with:
        path: .
        format: spdx-json
        output-file: sbom.spdx.json

    - name: ğŸ“ Generate Release Notes
      if: steps.check_release.outputs.exists == 'false'
      id: release_notes
      run: |
        echo "ğŸ“ Generating comprehensive release notes..."

        # Make script executable and run it
        chmod +x .github/scripts/generate-release-notes.sh
        ./.github/scripts/generate-release-notes.sh "${{ steps.version.outputs.version }}" "${{ steps.version.outputs.previous_tag }}"

        echo "âœ… Release notes generated"

        # Output first few lines for verification
        echo "ğŸ“„ Release notes preview:"
        head -10 release_notes.md

    - name: Upload Build Artifacts
      if: steps.check_release.outputs.exists == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: brainarr-plugin-${{ steps.version.outputs.version }}
        path: |
          Brainarr-${{ steps.version.outputs.version }}.zip
          Brainarr-${{ steps.version.outputs.version }}.zip.sha256
          release/
        retention-days: 90

    - name: ğŸ Create GitHub Release
      if: steps.check_release.outputs.exists == 'false'
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.version }}
        name: "ğŸ§  Brainarr ${{ steps.version.outputs.version }} - AI-Powered Music Discovery"
        body_path: release_notes.md
        draft: ${{ github.event.inputs.draft == 'true' }}
        prerelease: ${{ steps.version.outputs.prerelease == 'true' }}
        files: |
          Brainarr-${{ steps.version.outputs.version }}.zip
          Brainarr-${{ steps.version.outputs.version }}.zip.sha256
          sbom.spdx.json
        generate_release_notes: false  # We're providing our own comprehensive notes

    - name: Move 'latest' tag to this release
      if: steps.check_release.outputs.exists == 'false' && github.ref_type == 'tag'
      shell: bash
      env:
        VERSION_TAG: ${{ steps.version.outputs.version }}
      run: |
        set -euo pipefail
        git fetch --tags --force
        git tag -f latest "$VERSION_TAG"
        # Delete remote 'latest' if exists, then push the new one
        git push origin :refs/tags/latest || true
        git push origin latest

    - name: ğŸ“š Update Wiki Documentation
      run: |
        echo "ğŸ“š Updating wiki documentation for release ${{ steps.version.outputs.version }}..."

        # Clone wiki repository
        git clone https://github.com/${{ github.repository }}.wiki.git wiki-repo || {
          echo "âš ï¸ Wiki repository doesn't exist yet - skipping wiki update"
          echo "ğŸ’¡ Wiki will be created when first page is added manually"
          exit 0
        }

        cd wiki-repo

        # Update version references in wiki content
        echo "ğŸ”„ Updating version references in wiki..."

        # Copy latest wiki content
        cp ../wiki-content/*.md . 2>/dev/null || echo "No wiki content to update"

        # Update version numbers in wiki pages
        sed -i "s/v1\.0\.3/${{ steps.version.outputs.version }}/g" *.md 2>/dev/null || true
        sed -i "s/Brainarr-v1\.0\.3/Brainarr-${{ steps.version.outputs.version }}/g" *.md 2>/dev/null || true

        # Update download URLs to latest
        sed -i "s|download/v1\.0\.3/|download/${{ steps.version.outputs.version }}/|g" *.md 2>/dev/null || true

        # Check for changes
        if git diff --quiet; then
          echo "â„¹ï¸ No wiki updates needed"
        else
          echo "ğŸ“ Committing wiki updates..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .
          git commit -m "docs: update wiki for release ${{ steps.version.outputs.version }}

          â€¢ Updated version references throughout documentation
          â€¢ Updated download URLs to latest release
          â€¢ Synchronized with codebase changes

          Auto-updated by release automation."

          git push origin master 2>/dev/null || git push origin main 2>/dev/null
          echo "âœ… Wiki updated successfully"
        fi

        cd ..
        rm -rf wiki-repo

    - name: ğŸ‰ Release Summary
      run: |
        echo "ğŸ‰ Successfully created release!"
        echo "ğŸ“¦ Release: Brainarr ${{ steps.version.outputs.version }}"
        echo "ğŸ”— URL: https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.version }}"
        echo "ğŸ“‹ Prerelease: ${{ steps.version.outputs.prerelease }}"
        echo "ğŸ’¾ Assets: Brainarr-${{ steps.version.outputs.version }}.zip + SHA256"
        echo "ğŸ“š Wiki: Updated with latest version references"
        echo ""
        echo "ğŸ“¥ Installation command:"
        echo "GitHub URL: https://github.com/${{ github.repository }}"
