name: Nightly Live-Service Tests

on:
  schedule:
    - cron: '0 3 * * *'  # 03:00 UTC daily
  workflow_dispatch:

permissions:
  contents: read
  issues: write  # Required for 3-consecutive-failure issue creation

concurrency:
  group: nightly-live-${{ github.ref }}
  cancel-in-progress: false

jobs:
  live-gate:
    name: Validate API Keys
    runs-on: ubuntu-latest
    outputs:
      has-any-key: ${{ steps.check.outputs.has-any-key }}
      key-summary: ${{ steps.check.outputs.key-summary }}
    steps:
      - name: Validate configured API keys
        id: check
        env:
          HAS_OPENAI: ${{ secrets.OPENAI_API_KEY != '' }}
          HAS_ANTHROPIC: ${{ secrets.ANTHROPIC_API_KEY != '' }}
          HAS_GROQ: ${{ secrets.GROQ_API_KEY != '' }}
          HAS_DEEPSEEK: ${{ secrets.DEEPSEEK_API_KEY != '' }}
          HAS_GEMINI: ${{ secrets.GEMINI_API_KEY != '' }}
          # Length sanity checks (non-empty + min length to catch placeholders)
          OPENAI_LEN: ${{ secrets.OPENAI_API_KEY && '1' || '0' }}
          ANTHROPIC_LEN: ${{ secrets.ANTHROPIC_API_KEY && '1' || '0' }}
          GROQ_LEN: ${{ secrets.GROQ_API_KEY && '1' || '0' }}
          DEEPSEEK_LEN: ${{ secrets.DEEPSEEK_API_KEY && '1' || '0' }}
          GEMINI_LEN: ${{ secrets.GEMINI_API_KEY && '1' || '0' }}
        run: |
          summary=""
          count=0
          for provider in OPENAI ANTHROPIC GROQ DEEPSEEK GEMINI; do
            var="HAS_${provider}"
            if [[ "${!var}" == "true" ]]; then
              summary="${summary}${provider}=configured "
              count=$((count + 1))
            fi
          done

          if [[ $count -gt 0 ]]; then
            echo "has-any-key=true" >> "$GITHUB_OUTPUT"
            echo "key-summary=${summary}" >> "$GITHUB_OUTPUT"
            echo "::notice::${count} AI provider key(s) configured: ${summary}"
          else
            echo "has-any-key=false" >> "$GITHUB_OUTPUT"
            echo "key-summary=none" >> "$GITHUB_OUTPUT"
            echo "::notice::No AI provider API keys configured; skipping live-service tests. Configure at least one of: OPENAI_API_KEY, ANTHROPIC_API_KEY, GROQ_API_KEY, DEEPSEEK_API_KEY, GEMINI_API_KEY"
          fi

  live-tests:
    name: Live AI Provider Tests
    needs: live-gate
    if: needs.live-gate.outputs.has-any-key == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: false
        token: ${{ github.token }}

    - name: Init Common submodule
      uses: ./.github/actions/init-common-submodule
      with:
        token: ${{ secrets.SUBMODULES_TOKEN }}

    - name: Setup .NET 8
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.0.x'

    - name: Patch submodule NuGet mapping (TagLibSharp-Lidarr)
      shell: bash
      run: |
        set -euo pipefail
        CFG="ext/Lidarr.Plugin.Common/NuGet.config"
        if [ -f "$CFG" ]; then
          grep -q 'TagLibSharp-Lidarr' "$CFG" || \
            sed -i '/<packageSource key="lidarr-taglib">/a \      <package pattern="TagLibSharp-Lidarr*" />' "$CFG"
        fi

    - name: Extract Lidarr Assemblies
      shell: bash
      run: |
        timeout 15m bash scripts/extract-lidarr-assemblies.sh --mode full --no-tar-fallback --output-dir ext/Lidarr-docker/_output/net8.0
        echo "Extracted assemblies (sample):"
        ls -1 ext/Lidarr-docker/_output/net8.0 2>/dev/null | head -20 || true

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: |
        dotnet build --configuration Release --no-restore \
          -p:LidarrPath="${{ github.workspace }}/ext/Lidarr-docker/_output/net8.0" \
          -p:PluginPackagingDisable=true \
          -p:BuildInParallel=false \
          /nodeReuse:false \
          -m:1

    - name: Run Live-Service E2E Tests
      id: run-tests
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        set +e
        mkdir -p TestResults
        dotnet test --configuration Release --no-build \
          --verbosity normal \
          --filter "Area=E2E/Live" \
          --blame-hang-timeout 60s \
          --logger "trx;LogFileName=live-service-results.trx" \
          --results-directory ./TestResults \
          -p:LidarrPath="${{ github.workspace }}/ext/Lidarr-docker/_output/net8.0" \
          2>&1 | tee TestResults/live-service.log
        exit_code=${PIPESTATUS[0]}
        set -e

        # Parse test counts from output
        total=0
        passed=0
        failed=0
        if grep -qP 'Total tests:\s*\d+' TestResults/live-service.log; then
          total=$(grep -oP 'Total tests:\s*\K\d+' TestResults/live-service.log | tail -1)
          passed=$(grep -oP 'Passed:\s*\K\d+' TestResults/live-service.log | tail -1 || echo 0)
          failed=$(grep -oP 'Failed:\s*\K\d+' TestResults/live-service.log | tail -1 || echo 0)
        fi

        # Anti-silence guard: secrets are present but 0 tests executed = misconfiguration
        zero_tests="false"
        if grep -qi "No test is available" TestResults/live-service.log || [[ "$total" -eq 0 ]]; then
          zero_tests="true"
        fi

        echo "test-exit-code=$exit_code" >> "$GITHUB_OUTPUT"
        echo "test-total=$total" >> "$GITHUB_OUTPUT"
        echo "test-passed=$passed" >> "$GITHUB_OUTPUT"
        echo "test-failed=$failed" >> "$GITHUB_OUTPUT"
        echo "zero-tests=$zero_tests" >> "$GITHUB_OUTPUT"

        echo "::notice::Test results: total=$total passed=$passed failed=$failed exit_code=$exit_code"

    - name: Guard — fail if secrets present but 0 tests ran
      if: steps.run-tests.outputs.zero-tests == 'true'
      run: |
        echo "::error::Secrets are configured but 0 live tests executed. This indicates a misconfigured test filter, missing test assembly, or broken test discovery. Fix the nightly-live workflow."
        exit 1

    - name: Record outcome for consecutive-failure tracking
      if: always()
      shell: bash
      run: |
        mkdir -p TestResults
        if [[ "${{ steps.run-tests.outputs.test-failed }}" != "0" ]] || [[ "${{ steps.run-tests.outputs.test-exit-code }}" != "0" ]]; then
          echo "fail" > TestResults/nightly-live-outcome.txt
        else
          echo "pass" > TestResults/nightly-live-outcome.txt
        fi
        echo "date=$(date -u +%Y-%m-%d)" >> TestResults/nightly-live-outcome.txt
        echo "total=${{ steps.run-tests.outputs.test-total }}" >> TestResults/nightly-live-outcome.txt
        echo "passed=${{ steps.run-tests.outputs.test-passed }}" >> TestResults/nightly-live-outcome.txt
        echo "failed=${{ steps.run-tests.outputs.test-failed }}" >> TestResults/nightly-live-outcome.txt

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: nightly-live-service-results
        path: ./TestResults/
        retention-days: 14

  notify-failures:
    name: Track Consecutive Failures
    needs: live-tests
    if: always() && needs.live-tests.result == 'failure'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      actions: read
    steps:
      - name: Check for 3 consecutive failures
        uses: actions/github-script@v7
        with:
          script: |
            // Check the last 3 nightly-live workflow runs
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'nightly-live.yml',
              status: 'completed',
              per_page: 4,  // current + 3 previous
            });

            // Skip the current run (index 0), count consecutive failures
            const previous = runs.workflow_runs.slice(1, 4);
            const consecutiveFailures = previous.filter(r => r.conclusion === 'failure').length;

            console.log(`Previous ${previous.length} runs: ${previous.map(r => r.conclusion).join(', ')}`);
            console.log(`Consecutive failures (excluding current): ${consecutiveFailures}`);

            // Current run failed + 2 previous failures = 3 consecutive
            if (consecutiveFailures >= 2) {
              const title = 'Nightly live-service tests: 3+ consecutive failures';
              const body = [
                '## Nightly Live-Service Test Failures',
                '',
                `The nightly live-service tests have failed **${consecutiveFailures + 1} consecutive times**.`,
                '',
                '### Recent runs',
                ...previous.map(r => `- ${r.created_at}: **${r.conclusion}** ([run](${r.html_url}))`),
                `- ${new Date().toISOString().split('T')[0]}: **failure** (current)`,
                '',
                '### Action needed',
                '- Check if API keys are still valid',
                '- Check if provider APIs have changed (response shape drift)',
                '- Check if test filter or build is misconfigured',
                '',
                '> This issue is auto-created by the nightly-live workflow.',
                '> Closing it will not prevent re-creation if failures continue.',
              ].join('\n');

              // Check for existing open issue
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'ci,nightly-live',
              });
              const existing = issues.find(i => i.title === title);

              if (existing) {
                // Update existing issue with latest info
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  body: `Still failing as of ${new Date().toISOString().split('T')[0]}. Total consecutive failures: ${consecutiveFailures + 1}.`,
                });
                console.log(`Updated existing issue #${existing.number}`);
              } else {
                // Create new issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title,
                  body,
                  labels: ['ci', 'nightly-live'],
                });
                console.log('Created new tracking issue');
              }
            } else {
              console.log('Not enough consecutive failures yet — no issue needed');
            }
