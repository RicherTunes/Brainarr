<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <!-- net8.0 only: Lidarr 3.x (required for plugins) runs on .NET 8 -->
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <AnalysisLevel>latest</AnalysisLevel>
    <AssemblyName>Lidarr.Plugin.Brainarr</AssemblyName>
    <RootNamespace>NzbDrone.Core.ImportLists.Brainarr</RootNamespace>
    <OutputPath>bin\</OutputPath>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Deterministic>true</Deterministic>
    <ContinuousIntegrationBuild>true</ContinuousIntegrationBuild>

    <!-- Assembly and build configuration -->
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>

    <!-- Baseline: do not fail builds on warnings; tighten in Debug below -->
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>

    <!-- Disable NuGet package's built-in ILRepack target - we use PluginPackaging.targets instead.
         The package still loads the ILRepack task definition which PluginPackaging.targets uses. -->
    <ILRepackEnabled>false</ILRepackEnabled>
  </PropertyGroup>

  <!-- In CI/test runs, copy Lidarr referenced assemblies next to plugin output so testhost can bind on Linux -->
  <PropertyGroup>
    <CopyLidarrRefsForTests Condition="'$(CopyLidarrRefsForTests)' == '' and '$(CI)' == 'true'">true</CopyLidarrRefsForTests>
    <CopyLidarrRefsForTests Condition="'$(CopyLidarrRefsForTests)' == ''">false</CopyLidarrRefsForTests>
  </PropertyGroup>

  <!-- Treat nullable-related warnings as errors in Debug to catch null-safety regressions -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <WarningsAsErrors>nullable</WarningsAsErrors>
  </PropertyGroup>

  <!-- Restrict broad warning suppressions to Release builds only.
       Debug builds surface nullable and other diagnostics to catch regressions early. -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <!-- CS0618: Obsolete member usage (common in plugin development)
         CS1998: Async method lacks 'await' (compatibility shims)
         CS86xx: Nullable flow warnings across DTOs and interop boundaries
         NU1903: NuGet vulnerabilities (tracked outside compile)
         MSB3277: Version conflicts resolved by Lidarr at runtime -->
    <NoWarn>CS0618;CS1998;CS8618;CS8625;CS8603;CS8604;CS8601;CS8602;CS8600;CS8619;CS8622;CS8629;NU1903;MSB3277</NoWarn>
  </PropertyGroup>

  <!-- Package dependencies -->
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" />
    <!-- NLog: Use Lidarr's version when available, fallback to package for CI -->
    <PackageReference Include="NLog" Condition="!Exists('$(LidarrPath)\NLog.dll')" />
    <!-- FluentValidation: use host DLL when available (FV 9.5.4), fall back to NuGet 9.5.4 for CI
         without Docker extraction. Plugin types cross the host boundary via NzbDroneValidationResult,
         so we must compile against the same major version the host ships. -->
    <PackageReference Include="FluentValidation" Condition="!Exists('$(LidarrPath)\FluentValidation.dll')" PrivateAssets="all" />
    <!-- System packages needed for compilation but provided by Lidarr runtime -->
    <PackageReference Include="System.Security.Cryptography.ProtectedData" />
  </ItemGroup>

  <!-- Embed JSON schema used for structured outputs so providers don't rely on filesystem paths -->
  <ItemGroup>
    <EmbeddedResource Include="Configuration\Defaults\RecommendationJsonSchema.json" />
    <EmbeddedResource Include="Resources\music_styles.json" />
    <EmbeddedResource Include="../docs/models.example.json">
      <LogicalName>Brainarr.docs.models.example.json</LogicalName>
    </EmbeddedResource>
    <EmbeddedResource Include="../docs/models.schema.json">
      <LogicalName>Brainarr.docs.models.schema.json</LogicalName>
    </EmbeddedResource>
  </ItemGroup>

  <!-- Ship example model registry + schema for offline defaults -->
  <ItemGroup>
    <Content Include="../docs/models.example.json">
      <Link>docs\models.example.json</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
    </Content>
    <Content Include="../docs/models.schema.json">
      <Link>docs\models.schema.json</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
    </Content>
  </ItemGroup>

  <!-- Analyzers (NetAnalyzers enabled via SDK); optional extra analyzers can be added later -->

  <!-- Lidarr assemblies reference -->
  <!-- Priority order:
       1. Command line property: -p:LidarrPath=...
       2. Environment variable: LIDARR_PATH
       3. Docker extraction: ../ext/Lidarr-docker/_output/net8.0
       4. Local checkout: ../ext/Lidarr/_output/net8.0
       5. Local source build: ../ext/Lidarr/src/Lidarr/bin/Release/net8.0
       6. GitHub Actions cache: ../lidarr/_output/net8.0
       7. System installation paths
  -->
  <PropertyGroup>
    <LidarrPath Condition="'$(LidarrPath)' == ''">$(LIDARR_PATH)</LidarrPath>
    <!-- Prefer docker-extracted assemblies (kept in sync with plugins branch) -->
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('..\ext\Lidarr-docker\_output\net8.0')">..\ext\Lidarr-docker\_output\net8.0</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('..\ext\Lidarr\_output\net8.0')">..\ext\Lidarr\_output\net8.0</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('..\ext\Lidarr\src\Lidarr\bin\Release\net8.0')">..\ext\Lidarr\src\Lidarr\bin\Release\net8.0</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('..\..\lidarr\_output\net8.0')">..\..\lidarr\_output\net8.0</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('C:\ProgramData\Lidarr\bin')">C:\ProgramData\Lidarr\bin</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('/opt/Lidarr')">/opt/Lidarr</LidarrPath>
    <LidarrPath Condition="'$(LidarrPath)' == '' AND Exists('/usr/lib/lidarr/bin')">/usr/lib/lidarr/bin</LidarrPath>
  </PropertyGroup>

  <!-- CI fallback path when the docker extraction is intentionally missing -->
  <PropertyGroup Condition="'$(CI)' == 'true' and '$(LidarrPath)' == ''">
    <LidarrPath Condition="'$(LidarrPath)' == ''">$(MSBuildThisFileDirectory)..\ext\Lidarr-docker\_output\net8.0</LidarrPath>
  </PropertyGroup>

  <ItemGroup Condition="'$(LidarrPath)' != ''">
    <Reference Include="Lidarr.Core">
      <HintPath>$(LidarrPath)\Lidarr.Core.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
    <Reference Include="Lidarr.Common">
      <HintPath>$(LidarrPath)\Lidarr.Common.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
    <Reference Include="Lidarr.Api.V1">
      <HintPath>$(LidarrPath)\Lidarr.Api.V1.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
    <Reference Include="Lidarr.Http">
      <HintPath>$(LidarrPath)\Lidarr.Http.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
    <Reference Include="Lidarr.Host">
      <HintPath>$(LidarrPath)\Lidarr.Host.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>

    <!-- FluentValidation: compile against the host's DLL (FV 9.5.4) to ensure type
         compatibility at the NzbDroneValidationResult boundary. -->
    <Reference Include="FluentValidation" Condition="Exists('$(LidarrPath)\FluentValidation.dll')">
      <HintPath>$(LidarrPath)\FluentValidation.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
    <!-- Microsoft.Extensions packages are managed via Central Package Management (Directory.Packages.props) -->
    <!-- This ensures consistent versions and compatibility across all environments -->

    <!-- Use Lidarr's NLog to avoid version conflicts -->
    <Reference Include="NLog" Condition="Exists('$(LidarrPath)\NLog.dll')">
      <HintPath>$(LidarrPath)\NLog.dll</HintPath>
      <Private>$(CopyLidarrRefsForTests)</Private>
    </Reference>
  </ItemGroup>

  <!-- Require Lidarr to be present for build -->
  <Target Name="ValidateLidarrPath" BeforeTargets="Build">
    <Error Condition="'$(LidarrPath)' == ''" Text="Lidarr installation not found. Run '.\setup-lidarr.ps1' or set LIDARR_PATH environment variable to your Lidarr installation directory" />
    <Message Condition="'$(LidarrPath)' != ''" Text="Using Lidarr from: $(LidarrPath)" Importance="high" />
  </Target>

  <!-- Copy plugin manifest to output -->
  <ItemGroup>
    <Content Include="..\plugin.json" Condition="Exists('..\plugin.json')">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <Content Include="../docs/models.example.json" Condition="Exists('../docs/models.example.json')">
      <Link>docs\models.example.json</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
    </Content>
    <Content Include="../docs/models.schema.json" Condition="Exists('../docs/models.schema.json')">
      <Link>docs\models.schema.json</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
    </Content>
  </ItemGroup>

  <!-- Additional package dependencies -->
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <!-- ILRepack: The package provides the ILRepack task definition.
         We override its automatic target below to do nothing.
         Our PluginPackaging.targets uses the ILRepack task with proper LibraryPath. -->
    <PackageReference Include="ILRepack.Lib.MSBuild.Task" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ext\Lidarr.Plugin.Common\src\Lidarr.Plugin.Common.csproj">
      <ReferenceOutputAssembly>true</ReferenceOutputAssembly>
      <Private>true</Private>
      <!-- Disable analyzers for the submodule to avoid PublicAPI duplicate warnings affecting our CI -->
      <AdditionalProperties>GeneratePackageOnBuild=false;RunAnalyzersDuringBuild=false;RunAnalyzersDuringCompilation=false;EnableNETAnalyzers=false;UseSharedCompilation=false</AdditionalProperties>
    </ProjectReference>
  </ItemGroup>


  <!-- ILRepack Configuration: Merge dependencies into single DLL for multi-plugin compatibility -->
  <PropertyGroup>
    <LidarrAssembliesPath>$(LidarrPath)</LidarrAssembliesPath>
  </PropertyGroup>

  <!-- Import shared plugin packaging targets from Lidarr.Plugin.Common -->
  <Import Project="..\ext\Lidarr.Plugin.Common\build\PluginPackaging.targets" Condition="Exists('..\ext\Lidarr.Plugin.Common\build\PluginPackaging.targets')" />
</Project>
